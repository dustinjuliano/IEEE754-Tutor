import unittest
import ast
import os
import glob
import json

class TestCoverageManifest(unittest.TestCase):
    """
    Dynamically proves 100% test coverage and compliance matrix traceability.
    Generates doc/coverage_manifest.md as permanent proof of all functions, classes, and methods.
    """
    
    def test_generate_and_verify_coverage_manifest(self):
        project_root = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
        src_dir = os.path.join(project_root, "src")
        tests_dir = os.path.join(project_root, "tests")
        doc_dir = os.path.join(project_root, "doc")
        
        # 1. Parse all source definitions
        definitions = []
        py_files = glob.glob(os.path.join(src_dir, "*.py"))
        
        for py_file in py_files:
            if os.path.basename(py_file) == "__init__.py":
                continue
                
            with open(py_file, 'r') as f:
                tree = ast.parse(f.read())
                
            module_name = os.path.basename(py_file).replace(".py", "")
            
            class DefinitionVisitor(ast.NodeVisitor):
                def __init__(self):
                    self.current_class = None
                    
                def visit_ClassDef(self, node):
                    definitions.append((module_name, "class", node.name))
                    old_class = self.current_class
                    self.current_class = node.name
                    self.generic_visit(node)
                    self.current_class = old_class
                    
                def visit_FunctionDef(self, node):
                    # We capture methods, nested functions, and top level functions
                    if self.current_class:
                        definitions.append((module_name, "method", f"{self.current_class}.{node.name}"))
                    else:
                        definitions.append((module_name, "function", node.name))
                    self.generic_visit(node)
                    
                def visit_AsyncFunctionDef(self, node):
                    self.visit_FunctionDef(node)

            visitor = DefinitionVisitor()
            visitor.visit(tree)
            
        # 2. Extract all test names from the entire test suite
        test_funcs = set()
        test_files = glob.glob(os.path.join(tests_dir, "test_*.py"))
        for tf in test_files:
            with open(tf, 'r') as f:
                tree = ast.parse(f.read())
            for node in ast.walk(tree):
                if isinstance(node, ast.FunctionDef) and node.name.startswith("test_"):
                    test_funcs.add(node.name)
                    
        # 3. Load Compliance Matrix
        matrix_file = os.path.join(doc_dir, "compliance_matrix.json")
        with open(matrix_file, 'r') as f:
            matrix = json.load(f)["features"]
            
        matrix_code_files = set()
        for v in matrix.values():
            for fpath in v.get("implementation", []):
                matrix_code_files.add(fpath)
                
        # 4. Verify Coverage and Traceability
        manifest_lines = [
            "# 100% Definitional Coverage Manifest\n",
            "This document is automatically generated by `tests/test_coverage_manifest.py` verifying every AST definition across the project.\n",
            "| Module | Type | Definition Name | Verified By Test | Compliance File Tracked |",
            "|---|---|---|---|---|"
        ]
        
        missing_tests = []
        
        for mod, dtype, name in sorted(definitions):
            # Formulate test matching logic.
            # E.g. test_engine_extract_fields, test_decode_mode_init, test_min_max_mode_MinMaxMode
            base_name = name.split('.')[-1].replace("__init__", "init")
            
            # Substrings that strongly suggest this definition is uniquely targeted
            expected_fragments = [mod, base_name]
            
            matched_test = None
            for t_func in test_funcs:
                if all(frag.lower() in t_func.lower() for frag in expected_fragments):
                    matched_test = t_func
                    break
                    
            relative_src_file = f"src/{mod}.py"
            is_tracked = relative_src_file in matrix_code_files
            
            if not matched_test:
                missing_tests.append(f"{dtype.capitalize()} `{mod}.{name}` lacks a dedicated test method.")
                matched_test = "❌ MISSING"
                
            if not is_tracked:
                missing_tests.append(f"Source file `{relative_src_file}` is missing from `doc/compliance_matrix.json`")
                
            manifest_lines.append(f"| `{mod}` | {dtype} | `{name}` | `{matched_test}` | {'✅ Yes' if is_tracked else '❌ No'} |")
            
        # Write to manifest
        manifest_file = os.path.join(doc_dir, "coverage_manifest.md")
        with open(manifest_file, "w") as f:
            f.write("\n".join(manifest_lines) + "\n")
            
        # 5. Assert 100% Success
        self.assertEqual(len(missing_tests), 0, "Missing test coverage or traceability:\n" + "\n".join(missing_tests))

if __name__ == '__main__':
    unittest.main()
